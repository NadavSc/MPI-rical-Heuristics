sample 0:
reference: int main ( int argc , char * * argv ) { int * buf ; int rank ; int nprocs ; int n ints ; int bufsize ; mpi _file fh ; mp i_ status status ; mpi _init ( & argc , & argv ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; mp i_ comm_ size ( mp i_ comm_ world , & nprocs ) ; bufsize = ( 1024 * 1024 ) / nprocs ; buf = ( int * ) malloc ( bufsize ) ; n ints = bufsize / ( sizeof ( int ) ) ; mpi _file_ open ( mp i_ comm_ world , ___str , 2 , mpi _info _null , & fh ) ; mpi _file_ seek ( fh , rank * bufsize , 600 ) ; mpi _file _read ( fh , buf , n ints , mp i_ int , & status ) ; mpi _file_ close ( & fh ) ; free ( buf ) ; mp i_ finalize ( ) ; return 0 ; }
candidate: int main ( int argc , char * * argv ) { int * buf ; int rank ; int nprocs ; int n ints ; int bufsize ; mpi _file fh ; mp i_ status status ; mpi _init ( & argc , & argv ) ; mp i_ comm_ size ( mp i_ comm_ world , & nprocs ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; bufsize = ( 1024 * 1024 ) / nprocs ; buf = ( int * ) malloc ( bufsize ) ; n ints = bufsize / ( sizeof ( int ) ) ; mpi _file_ open ( mp i_ comm_ world , ___str , 1 | 4 , mpi _info _null , & fh ) ; mpi _file _set_ view ( fh , bufsize , mp i_ int , mp i_ int , mp i_ int , mp i_ status_ ignore ) ; mpi _file_ close ( & fh ) ; free ( buf ) ; mp i_ finalize ( ) ; return 0 ; }

sample 1:
reference: int main ( int argc , char * argv [ ] ) { int cidx ; int eager size ; int nvals ; int err ; int required = mp i_ thread _single ; int provided ; mp i_ t_ c var _handle ch andle ; mp i_ t_ enum enumtype ; mp i_ datatype datatype ; mpi _init _thread ( 0 , 0 , required , & provided ) ; mp i_ t_ init_ thread ( required , & provided ) ; err = mp i_ t_ c var _get_ index ( ___str , & cidx ) ; if ( err ! = 0 ) mp i_ abort ( 0 , mp i_ comm_ world ) ; err = mp i_ t_ c var _handle_ alloc ( cidx , 0 , & ch andle , & nvals ) ; if ( nvals ! = 1 ) printf ( ___str , nvals ) ; err = mp i_ t_ c var _read ( ch andle , & eager size ) ; printf ( ___str , eager size ) ; eager size = 1024 ; err = mp i_ t_ c var _write ( ch andle , & eager size ) ; err = mp i_ t_ c var _read ( ch andle , & eager size ) ; if ( eager size ! = 1024 ) printf ( ___str ) ; mp i_ t_ c var _handle _free ( & ch andle ) ; mp i_ t_ finalize ( ) ; mp i_ finalize ( ) ; }
candidate: int main ( int argc , char * argv [ ] ) { int cidx ; int eager size ; int nvals ; int err ; int required = mp i_ thread _single ; int provided ; mp i_ t_ c var _handle ch andle ; mp i_ t_ enum enumtype ; mp i_ datatype datatype ; mpi _init ( & argc , & argv ) ; mp i_ comm_ size ( ( mp i_ comm ) 0x 44 000000 , & eager size ) ; mp i_ comm_ rank ( ( mp i_ comm ) 0x 44 000000 , & eager size ) ; err = mp i_ t_ c var _handle ch andle ; if ( ! = 0 ) { mp i_ abort ( ( mp i_ comm ) 0x 44 000000 , 1 ) ; } err = mp i_ t_ enum enumtype ; if ( nvals ! = 1 ) printf ( ___str , nvals ) ; err = mp i_ t_ size ; if ( ! = 1 ) { mp i_ abort ( ( mp i_ comm ) 0x 44 000000 , 1 ) ; } if ( ! eager size ) { mp i_ abort ( ( mp i_ comm ) 0x 44 000000 , 1 ) ; } eager size = 1024 ; err = mp i_ t_ c var _handle ch andle ; if ( eager size ! = 1024 ) printf ( ___str ) ; mp i_ abort ( ( mp i_ comm ) 0x 44 000000 , 1 ) ; mp i_ comm_ set_ errhandler ( ( mp i_ comm ) 0x 44 000000 , ( mp i_ errhandler ) 0x 54 000000 ) ; err = mp i_ t_ c var _handle ch andle ; if ( eager size ! = 1024 ) printf ( ___str ) ; mp i_ finalize ( ) ; }

sample 2:
reference: int main ( int argc , char * argv [ ] ) { int i ; int num _c var ; int namelen ; int verbosity ; int des clen ; int binding ; int required = mp i_ thread _single ; int provided ; int err ; int scope ; char name [ 128 ] ; char desc [ 1024 ] ; mp i_ t_ enum enumtype ; mp i_ datatype datatype ; mpi _init _thread ( 0 , 0 , required , & provided ) ; mp i_ t_ init_ thread ( required , & provided ) ; mp i_ t_ c var _get_ num ( & num _c var ) ; printf ( ___str , num _c var ) ; for ( i = 0 ; i < num _c var ; i ++ ) { namelen = sizeof ( name ) ; des clen = sizeof ( desc ) ; err = mp i_ t_ c var _get_ info ( i , name , & namelen , & verbosity , & datatype , & enumtype , desc , & des clen , & binding , & scope ) ; printf ( ___str , name , desc ) ; } mp i_ t_ finalize ( ) ; mp i_ finalize ( ) ; return 0 ; }
candidate: int main ( int argc , char * argv [ ] ) { int i ; int num _c var ; int namelen ; int verbosity ; int des clen ; int binding ; int required = mp i_ thread _single ; int provided ; int err ; int scope ; char name [ 128 ] ; char desc [ 1024 ] ; mp i_ t_ enum enumtype ; mp i_ datatype datatype ; mpi _init ( & argc , & argv ) ; mp i_ comm_ rank ( mp i_ comm_ world , & num _c var ) ; mp i_ comm_ size ( mp i_ comm_ world , & num _c var ) ; if ( num _c var ! = 0 ) { printf ( ___str , num _c var ) ; mp i_ abort ( mp i_ comm_ world , 1 ) ; } for ( i = 0 ; i < num _c var ; i ++ ) { namelen = sizeof ( name ) ; des clen = sizeof ( desc ) ; err = mpi _get_ count ( & desc , mp i_ char , & namelen ) ; printf ( ___str , name , desc ) ; } mp i_ finalize ( ) ; return 0 ; }

sample 3:
reference: int main ( int argc , char * argv [ ] ) { mp i_ comm counter _comm ; mp i_ comm worker_ comm ; mpi _init ( & argc , & argv ) ; m pe _counter _create ( mp i_ comm_ world , & worker_ comm , & counter _comm ) ; if ( worker_ comm ! = ( mp i_ comm_ null ) ) { int value ; int rank ; mp i_ comm_ rank ( counter _comm , & rank ) ; m pe _counter _n xt val ( counter _comm , & value ) ; printf ( ___str , rank , value ) ; m pe _counter _free ( & worker_ comm , & counter _comm ) ; } mp i_ finalize ( ) ; return 0 ; }
candidate: int main ( int argc , char * argv [ ] ) { mp i_ comm counter _comm ; mp i_ comm worker_ comm ; m pe _counter _create ( mp i_ comm_ world , & worker_ comm , & counter _comm ) ; int value ; int rank ; m pe _counter _n xt val ( counter _comm , & value ) ; mpi _init ( & argc , & argv ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; mp i_ comm_ size ( mp i_ comm_ world , & counter _comm ) ; printf ( ___str , rank , value ) ; m pe _counter _free ( & worker_ comm , & counter _comm ) ; mp i_ finalize ( ) ; return 0 ; }

sample 4:
reference: int main ( int argc , char * argv [ ] ) { int n ; int my id ; int numpro cs ; int i ; double pi 25 dt = 3 . 14 15 9 26 5 35 8 97 9 32 38 46 2 64 3 ; double my pi ; double pi ; double h ; double sum ; double x ; mpi _init ( & argc , & argv ) ; mp i_ comm_ size ( mp i_ comm_ world , & numpro cs ) ; mp i_ comm_ rank ( mp i_ comm_ world , & my id ) ; while ( 1 ) { if ( my id == 0 ) { printf ( ___str ) ; scan f ( ___str , & n ) ; } mpi _b cast ( & n , 1 , mp i_ int , 0 , mp i_ comm_ world ) ; if ( n == 0 ) break ; else { h = 1 . 0 / ( ( double ) n ) ; sum = 0 . 0 ; for ( i = my id + 1 ; i < = n ; i += numpro cs ) { x = h * ( ( ( double ) i ) - 0 . 5 ) ; sum += 4 . 0 / ( 1 . 0 + ( x * x ) ) ; } my pi = h * sum ; mpi _reduce ( & my pi , & pi , 1 , mp i_ double , mpi _sum , 0 , mp i_ comm_ world ) ; if ( my id == 0 ) printf ( ___str , pi , fabs ( pi - pi 25 dt ) ) ; } } mp i_ finalize ( ) ; return 0 ; }
candidate: int main ( int argc , char * argv [ ] ) { int n ; int my id ; int numpro cs ; int i ; double pi 25 dt = 3 . 14 15 9 26 5 35 8 97 9 32 38 46 2 64 3 ; double my pi ; double pi ; double h ; double sum ; double x ; mpi _init ( & argc , & argv ) ; mp i_ comm_ size ( mp i_ comm_ world , & numpro cs ) ; mp i_ comm_ rank ( mp i_ comm_ world , & my id ) ; while ( 1 ) { if ( my id == 0 ) { printf ( ___str ) ; scan f ( ___str , & n ) ; } mpi _b cast ( & n , 1 , mp i_ int , 0 , mp i_ comm_ world ) ; if ( n == 0 ) break ; else { h = 1 . 0 / ( ( double ) n ) ; sum = 0 . 0 ; for ( i = my id + 1 ; i < = n ; i += numpro cs ) { x = h * ( ( ( double ) i ) - 0 . 5 ) ; sum += 4 . 0 / ( 1 . 0 + ( x * x ) ) ; } my pi = h * sum ; mpi _reduce ( & my pi , & pi , 1 , mp i_ double , mpi _sum , 0 , mp i_ comm_ world ) ; if ( my id == 0 ) printf ( ___str , pi , fabs ( pi - pi 25 dt ) ) ; } } mp i_ finalize ( ) ; return 0 ; }

sample 5:
reference: int main ( int argc , char * * argv ) { int * buf ; int rank ; int nprocs ; int n ints ; int bufsize ; mpi _file fh ; mp i_ datatype filetype ; mpi _init ( & argc , & argv ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; mp i_ comm_ size ( mp i_ comm_ world , & nprocs ) ; bufsize = 1048576 / nprocs ; buf = ( int * ) malloc ( bufsize ) ; n ints = bufsize / ( sizeof ( int ) ) ; mpi _file_ open ( mp i_ comm_ world , ___str , 2 , mpi _info _null , & fh ) ; mpi _type_ vector ( n ints / 16 , 16 , 16 * nprocs , mp i_ int , & filetype ) ; mpi _type_ commit ( & filetype ) ; mpi _file _set_ view ( fh , ( 16 * ( sizeof ( int ) ) ) * rank , mp i_ int , filetype , ___str , mpi _info _null ) ; mpi _file _read_ all ( fh , buf , n ints , mp i_ int , mp i_ status_ ignore ) ; mpi _file_ close ( & fh ) ; mpi _type _free ( & filetype ) ; free ( buf ) ; mp i_ finalize ( ) ; return 0 ; }
candidate: int main ( int argc , char * * argv ) { int * buf ; int rank ; int nprocs ; int n ints ; int bufsize ; mpi _file fh ; mp i_ datatype filetype ; mpi _init ( & argc , & argv ) ; mp i_ comm_ rank ( ( mp i_ comm ) 0x 44 000000 , & rank ) ; mp i_ comm_ size ( ( mp i_ comm ) 0x 44 000000 , & nprocs ) ; bufsize = 1048576 / nprocs ; buf = ( int * ) malloc ( bufsize ) ; n ints = bufsize / ( sizeof ( int ) ) ; mpi _file_ open ( ( mp i_ comm ) 0x 44 000000 , ___str , 1 | 4 , mpi _info _null , & fh ) ; mpi _file _set_ view ( fh , ( mp i_ datatype ) 0x4 c 000 405 , n ints , bufsize , ( mp i_ datatype ) 0x4 c 000 405 , ( mp i_ op ) 0x 58 00000 3 , fh ) ; mpi _file _set_ view ( fh , ( mp i_ datatype ) 0x4 c 000 405 , n ints , ( mp i_ datatype ) 0x4 c 000 405 , ( mp i_ op ) 0x 58 00000 3 , fh ) ; mpi _file_ close ( & fh ) ; free ( buf ) ; mp i_ finalize ( ) ; return 0 ; }

sample 6:
reference: int main ( int argc , char * * argv ) { int i ; int nkeys ; int flag ; int rank ; mpi _file fh ; mpi _info info_ used ; char key [ 36 ] ; char value [ 256 ] ; mpi _init ( & argc , & argv ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; mpi _file_ open ( mp i_ comm_ world , ___str , 1 | 8 , mpi _info _null , & fh ) ; mpi _file _get_ info ( fh , & info_ used ) ; mpi _info _get_ nkeys ( info_ used , & nkeys ) ; for ( i = 0 ; i < nkeys ; i ++ ) { mpi _info _get_ nth key ( info_ used , i , key ) ; mpi _info _get ( info_ used , key , 256 , value , & flag ) ; printf ( ___str , rank , key , value ) ; } mpi _file_ close ( & fh ) ; mpi _info _free ( & info_ used ) ; mp i_ finalize ( ) ; return 0 ; }
candidate: int main ( int argc , char * * argv ) { int i ; int nkeys ; int flag ; int rank ; mpi _file fh ; mpi _info info_ used ; char key [ 36 ] ; char value [ 256 ] ; mpi _init ( & argc , & argv ) ; mp i_ comm_ rank ( ( mp i_ comm ) 0x 44 000000 , & rank ) ; mp i_ comm_ size ( ( mp i_ comm ) 0x 44 000000 , & nkeys ) ; mpi _info _create ( & info ) ; mpi _info _set ( info , ___str , ___str ) ; for ( i = 0 ; i < nkeys ; i ++ ) { mpi _info _set ( info , ___str , ___str ) ; mp i_ comm_ dup ( ( mp i_ comm ) 0x 44 000000 , & info_ used ) ; printf ( ___str , rank , key , value ) ; } mpi _info _free ( & fh ) ; mpi _info _free ( & info_ used ) ; mp i_ finalize ( ) ; return 0 ; }

sample 7:
reference: int main ( int argc , char * argv [ ] ) { int provided ; int err ; int nump var ; int namelen ; int des clen ; int verbosity ; int var class ; int binding ; int isreadonly ; int is continuous ; int is atomic ; int i ; char name [ 128 ] ; char desc [ 1024 ] ; mp i_ t_ enum enumtype ; mp i_ datatype datatype ; mpi _init _thread ( 0 , 0 , mp i_ thread _single , & provided ) ; err = mp i_ t_ init_ thread ( mp i_ thread _single , & provided ) ; if ( err ) mp i_ abort ( mp i_ comm_ world , 0 ) ; err = mp i_ t_ p var _get_ num ( & nump var ) ; if ( err ) mp i_ abort ( mp i_ comm_ world , 0 ) ; printf ( ___str , nump var ) ; for ( i = 0 ; i < nump var ; i ++ ) { namelen = sizeof ( name ) ; des clen = sizeof ( desc ) ; err = mp i_ t_ p var _get_ info ( i , name , & namelen , & verbosity , & var class , & datatype , & enumtype , desc , & des clen , & binding , & isreadonly , & is continuous , & is atomic ) ; if ( err ) mp i_ abort ( mp i_ comm_ world , 0 ) ; printf ( ___str , name , var class , ( isreadonly ) ? ( ___str ) : ( ___str ) , ( is continuous ) ? ( ___str ) : ( ___str ) , ( is atomic ) ? ( ___str ) : ( ___str ) , desc ) ; } mp i_ t_ finalize (
candidate: int main ( int argc , char * argv [ ] ) { int provided ; mpi _init _thread ( & argc , & argv , mp i_ thread _multiple , & provided ) ; int nump var ; int namelen ; int namelen ; mp i_ comm_ size ( mp i_ comm_ world , & nump var ) ; mp i_ comm_ rank ( mp i_ comm_ world , & nump var ) ; int des clen ; int var class ; int isleft ; int is trad ; int is atomic ; int i ; char name [ 128 ] ; char desc [ 1024 ] ; mp i_ t_ enum enumtype ; mp i_ datatype datatype ; mp i_ datatype datatype ; err = mp i_ alloc _mem ( 1024 * ( sizeof ( char * ) ) , sizeof ( char * ) , mpi _info _null , & name ) ; if ( ! err ) { err = mp i_ send ( & name , 1 , mp i_ char , 1 , 0 , mp i_ comm_ world ) ; printf ( ___str , nump var ) ; for ( i = 0 ; i < nump var ; i ++ ) { namelen = sizeof ( name ) ; des clen = sizeof ( desc ) ; err = mp i_ send ( & name , 1 , mp i_ char , 1 , 0 , mp i_ comm_ world ) ; printf ( ___str , name , var class , ( _estimate ) ? ( ___str ) : ( ___str ) , ( is ive ) ? ( ___str ) : ( ___str ) , ( is atomic ) ? ( ___str ) : ( ___str ) , desc ) ; } } mp i_ finalize ( ) ; return 0 ; }

sample 8:
reference: int main ( int argc , char * argv [ ] ) { int wr ank ; mpi _init ( & argc , & argv ) ; mp i_ comm_ rank ( mp i_ comm_ world , & wr ank ) ; seq begin ( mp i_ comm_ world ) ; printf ( ___str , wr ank ) ; ff lush ( stdout ) ; seq end ( mp i_ comm_ world ) ; printf ( ___str , wr ank ) ; mp i_ finalize ( ) ; return 0 ; }
candidate: int main ( int argc , char * argv [ ] ) { int wr ank ; mpi _init ( & argc , & argv ) ; mp i_ comm_ rank ( mp i_ comm_ world , & wr ank ) ; seq begin ( mp i_ comm_ world ) ; printf ( ___str , wr ank ) ; ff lush ( stdout ) ; seq end ( mp i_ comm_ world ) ; mp i_ finalize ( ) ; printf ( ___str , wr ank ) ; return 0 ; }

sample 9:
reference: int main ( int argc , char * argv [ ] ) { mp i_ comm counter _comm ; mp i_ comm worker_ comm ; mpi _init ( & argc , & argv ) ; m pe _counter _create_ ic ( mp i_ comm_ world , & worker_ comm , & counter _comm ) ; if ( worker_ comm ! = ( mp i_ comm_ null ) ) { int value ; int rank ; mp i_ comm_ rank ( counter _comm , & rank ) ; m pe _counter _n xt val_ ic ( counter _comm , & value ) ; printf ( ___str , rank , value ) ; m pe _counter _free _ ic ( & worker_ comm , & counter _comm ) ; } mp i_ finalize ( ) ; return 0 ; }
candidate: int main ( int argc , char * argv [ ] ) { mp i_ comm counter _comm ; mp i_ comm worker_ comm ; m pe _counter _create_ ic ( mp i_ comm_ world , & worker_ comm , & counter _comm ) ; int value ; int rank ; m pe _counter _n xt val_ ic ( counter _comm , & value ) ; mpi _init ( & argc , & argv ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; mp i_ comm_ size ( mp i_ comm_ world , & counter _comm ) ; printf ( ___str , rank , value ) ; m pe _counter _free _ ic ( & worker_ comm , & counter _comm ) ; mp i_ finalize ( ) ; return 0 ; }

test_loss: 1.7926788330078125
test_bleu: 0.7631405036402663
test_meteor: 0.48546988692407067
test_rouge-l: 0.7776827704164728
test_avg_precision: 0.8673850635568806
test_avg_recall: 0.8801102207462371
test_avg_f1: 0.8728725192965232
test_accuracy: 0.1
test_runtime: 14.6768
test_samples_per_second: 0.681
test_steps_per_second: 0.068
