sample 0:
reference: int main ( int argc , char * argv [ ] ) { mpi _init ( & argc , & argv ) ; int size ; int rank ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; const int total_ elements = 100 ; const int element s_per_ process = total_ elements / size ; int start_index = rank * element s_per_ process ; int end_index = ( rank + 1 ) * element s_per_ process ; if ( rank == ( size - 1 ) ) { end_index = total_ elements ; } sr and ( rank ) ; int * local_ array = ( int * ) malloc ( element s_per_ process * ( sizeof ( int ) ) ) ; for ( int i = start_index ; i < end_index ; ++ i ) { local_ array [ i - start_index ] = rand ( ) % 100 ; } int local _sum = 0 ; for ( int i = 0 ; i < element s_per_ process ; ++ i ) { local _sum += local_ array [ i ] ; } int global _sum = 0 ; mpi _reduce ( & local _sum , & global _sum , 1 , mp i_ int , mpi _sum , 0 , mp i_ comm_ world ) ; double average = ( ( double ) global _sum ) / total_ elements ; if ( rank == 0 ) { printf ( ___str , average ) ; } free ( local_ array ) ; mp i_ finalize ( ) ; return 0 ; }
candidate: int main ( int argc , char * argv [ ] ) { mpi _init ( & argc , & argv ) ; int size ; int rank ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; const int total_ elements = 100 ; const int element s_per_ process = total_ elements / size ; int start_index = rank * element s_per_ process ; int end_index = ( rank + 1 ) * element s_per_ process ; if ( rank == ( size - 1 ) ) { end_index = total_ elements ; } sr and ( rank ) ; int * local_ array = ( int * ) malloc ( element s_per_ process * ( sizeof ( int ) ) ) ; for ( int i = start_index ; i < end_index ; ++ i ) { local_ array [ i - start_index ] = rand ( ) % 100 ; } int local _sum = 0 ; for ( int i = 0 ; i < element s_per_ process ; ++ i ) { local _sum += local_ array [ i ] ; } int global _sum = 0 ; for ( int i = 0 ; i < ( sizeof ( local _sum ) ) ; i ++ ) { global _sum += local _sum [ i ] ; } double average = ( ( double ) global _sum ) / total_ elements ; if ( rank == 0 ) { printf ( ___str , average ) ; } free ( local_ array ) ; mp i_ finalize ( ) ; return 0 ; }

sample 1:
reference: int main ( int argc , char * argv [ ] ) { mpi _init ( & argc , & argv ) ; int size ; int rank ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; int num = 10 ; if ( num < = 0 ) { if ( rank == 0 ) { printf ( ___str ) ; } mp i_ finalize ( ) ; return 1 ; } int iteration s_per_ process = num / size ; int remaining_ iterations = num % size ; int start_ iteration = ( rank * iteration s_per_ process ) + 1 ; int end_ iteration = ( rank == ( size - 1 ) ) ? ( num ) : ( ( rank + 1 ) * iteration s_per_ process ) ; long long local_ factorial = 1 ; for ( int i = start_ iteration ; i < = end_ iteration ; i ++ ) { local_ factorial * = i ; } long long * local_ factor ials = ( long long * ) malloc ( size * ( sizeof ( long long ) ) ) ; mp i_ all gather ( & local_ factorial , 1 , mp i_ long_ long _int , local_ factor ials , 1 , mp i_ long_ long _int , mp i_ comm_ world ) ; long long total_ factorial = 1 ; if ( rank == 0 ) { for ( int i = 0 ; i < size ; i ++ ) { total_ factorial * = local_ factor ials [ i ] ; } } if ( rank == 0 ) { printf ( ___str , num , total_ factorial ) ; } free ( local_ factor ials ) ; mp i_ finalize ( ) ;
candidate: int main ( int argc , char * argv [ ] ) { int size ; int rank ; int num = 10 ; mpi _init ( & argc , & argv ) ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; if ( num < = 0 ) { if ( rank == 0 ) { printf ( ___str ) ; } mp i_ finalize ( ) ; return 1 ; } int iteration s_per_ process = num / size ; int remaining_ iterations = num % size ; int start_ iteration = ( rank * iteration s_per_ process ) + 1 ; int end_ iteration = ( rank == ( size - 1 ) ) ? ( num ) : ( ( rank + 1 ) * iteration s_per_ process ) ; long long local_ factorial = 1 ; for ( int i = start_ iteration ; i < = end_ iteration ; i ++ ) { local_ factorial * = i ; } long long * local_ factor = ( long long * ) malloc ( size * ( sizeof ( long long ) ) ) ; long long total_ factorial = 1 ; if ( rank == 0 ) { for ( int i = 0 ; i < size ; i ++ ) { total_ factorial * = local_ factor matri [ i ] ; } } if ( rank == 0 ) { printf ( ___str , num , total_ factorial ) ; } free ( local_ factor sonly ) ; mp i_ finalize ( ) ; return 0 ; }

sample 2:
reference: int main ( int argc , char * argv [ ] ) { mpi _init ( & argc , & argv ) ; int size ; int rank ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; double interval _width = 1 . 0 / 1000000 00 ; int local_ intervals = 1000000 00 / size ; double local _sum = 0 . 0 ; for ( int i = rank * local_ intervals ; i < ( ( rank + 1 ) * local_ intervals ) ; i ++ ) { double x = ( i + 0 . 5 ) * interval _width ; local _sum += f ( x ) ; } double global _sum ; mpi _reduce ( & local _sum , & global _sum , 1 , mp i_ double , mpi _sum , 0 , mp i_ comm_ world ) ; if ( rank == 0 ) { double pi = global _sum * interval _width ; printf ( ___str , pi ) ; } mp i_ finalize ( ) ; return 0 ; }
candidate: int main ( int argc , char * argv [ ] ) { mpi _init ( & argc , & argv ) ; int size ; int rank ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; double interval _width = 1 . 0 / 1000000 00 ; int local_ intervals = 1000000 00 / size ; double local _sum = 0 . 0 ; for ( int i = rank * local_ intervals ; i < ( ( rank + 1 ) * local_ intervals ) ; i ++ ) { double x = ( i + 0 . 5 ) * interval _width ; local _sum += f ( x ) ; } double global _sum ; for ( int i = 0 ; i < ( sizeof ( local _sum ) ) ; i ++ ) { global _sum += local _sum [ i ] ; } mpi _reduce ( & global _sum , & global _sum , 1 , mp i_ double , mpi _sum , 0 , mp i_ comm_ world ) ; if ( rank == 0 ) { double pi = global _sum * interval _width ; printf ( ___str , pi ) ; } mp i_ finalize ( ) ; return 0 ; }

sample 3:
reference: int main ( int argc , char * argv [ ] ) { mpi _init ( & argc , & argv ) ; int size ; int rank ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; int n = 10 ; if ( rank == 0 ) { printf ( ___str , n ) ; } int local_ n = n / size ; int start = ( rank * local_ n ) + 1 ; int end = ( rank + 1 ) * local_ n ; if ( rank == ( size - 1 ) ) { end = n ; } int local_ result = 0 ; for ( int i = start ; i < = end ; i ++ ) { local_ result += fibon acci ( i ) ; } int global_ result ; mpi _reduce ( & local_ result , & global_ result , 1 , mp i_ int , mpi _sum , 0 , mp i_ comm_ world ) ; if ( rank == 0 ) { printf ( ___str , n , global_ result ) ; } mp i_ finalize ( ) ; return 0 ; }
candidate: int main ( int argc , char * argv [ ] ) { int size ; int rank ; mpi _init ( & argc , & argv ) ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; int n = 10 ; if ( rank == 0 ) { printf ( ___str , n ) ; } int local_ n = n / size ; int start = ( rank * local_ n ) + 1 ; int end = ( rank + 1 ) * local_ n ; if ( rank == ( size - 1 ) ) { end = n ; } int local_ result = 0 ; for ( int i = start ; i < = end ; i ++ ) { local_ result += fibon acci ( i ) ; } int global_ result ; for ( int i = 0 ; i < ( sizeof ( local_ result ) ) ; i ++ ) { global_ result += local_ result [ i ] ; } mpi _reduce ( & local_ result , & global_ result , 1 , mp i_ int , mpi _sum , 0 , mp i_ comm_ world ) ; if ( rank == 0 ) { printf ( ___str , n , global_ result ) ; } mp i_ finalize ( ) ; return 0 ; }

sample 4:
reference: int main ( int argc , char * argv [ ] ) { mpi _init ( & argc , & argv ) ; int size ; int rank ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; double a = 0 . 0 ; double b = 1 . 0 ; double local _integr al = integrate ( a + ( ( ( b - a ) * rank ) / size ) , a + ( ( ( b - a ) * ( rank + 1 ) ) / size ) , 1000000000 / size ) ; double global_ integral ; mpi _reduce ( & local _integr al , & global_ integral , 1 , mp i_ double , mpi _sum , 0 , mp i_ comm_ world ) ; if ( rank == 0 ) { printf ( ___str , a , b , global_ integral ) ; } mp i_ finalize ( ) ; return 0 ; }
candidate: int main ( int argc , char * argv [ ] ) { int size ; int rank ; mpi _init ( & argc , & argv ) ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; double a = 0 . 0 ; double b = 1 . 0 ; double local _integr al = integrate ( a + ( ( ( b - a ) * rank ) / size ) , a + ( ( ( b - a ) * ( rank + 1 ) ) / size ) , 1000000000 / size ) ; double global_ integral ; for ( int i = 0 ; i < ( sizeof ( local _integr al ) ) ; i ++ ) { global_ integral += local _integr al [ i ] ; } mpi _reduce ( & global_ integral , & global_ integral , 1 , mp i_ double , mpi _sum , 0 , mp i_ comm_ world ) ; if ( rank == 0 ) { printf ( ___str , a , b , global_ integral ) ; } mp i_ finalize ( ) ; return 0 ; }

sample 5:
reference: int main ( int argc , char * argv [ ] ) { mpi _init ( & argc , & argv ) ; int size ; int rank ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; int * vector a = ( int * ) malloc ( 100 * ( sizeof ( int ) ) ) ; int * vector b = ( int * ) malloc ( 100 * ( sizeof ( int ) ) ) ; for ( int i = 0 ; i < 100 ; ++ i ) { vector a [ i ] = rand ( ) % 100 ; vector b [ i ] = rand ( ) % 100 ; } int local_ dot_ product = 0 ; int element s_per_ process = 100 / size ; int start_index = rank * element s_per_ process ; int end_index = ( rank == ( size - 1 ) ) ? ( 100 ) : ( ( rank + 1 ) * element s_per_ process ) ; for ( int i = start_index ; i < end_index ; ++ i ) { local_ dot_ product += vector a [ i ] * vector b [ i ] ; } int global_ dot_ product = 0 ; mpi _reduce ( & local_ dot_ product , & global_ dot_ product , 1 , mp i_ int , mpi _sum , 0 , mp i_ comm_ world ) ; if ( rank == 0 ) { printf ( ___str , global_ dot_ product ) ; } free ( vector a ) ; free ( vector b ) ; mp i_ finalize ( ) ; return 0 ; }
candidate: int main ( int argc , char * argv [ ] ) { int size ; int rank ; mpi _init ( & argc , & argv ) ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; int * vector a = ( int * ) malloc ( 100 * ( sizeof ( int ) ) ) ; int * vector b = ( int * ) malloc ( 100 * ( sizeof ( int ) ) ) ; for ( int i = 0 ; i < 100 ; ++ i ) { vector a [ i ] = rand ( ) % 100 ; vector b [ i ] = rand ( ) % 100 ; } int local_ dot_ product = 0 ; int element s_per_ process = 100 / size ; int start_index = rank * element s_per_ process ; int end_index = ( rank == ( size - 1 ) ) ? ( 100 ) : ( ( rank + 1 ) * element s_per_ process ) ; for ( int i = start_index ; i < end_index ; ++ i ) { local_ dot_ product += vector a [ i ] * vector b [ i ] ; } int global_ dot_ product = 0 ; for ( int i = 0 ; i < ( sizeof ( local_ dot_ product ) ) ; i ++ ) { global_ dot_ product += local_ dot_ product [ i ] ; } if ( rank == 0 ) { printf ( ___str , global_ dot_ product ) ; } free ( vector a ) ; free ( vector b ) ; mp i_ finalize ( ) ; return 0 ; }

sample 6:
reference: int main ( int argc , char * argv [ ] ) { mpi _init ( & argc , & argv ) ; int size ; int rank ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; const int array_size = 100 ; sr and ( rank ) ; int * local_ array = ( int * ) malloc ( array_size * ( sizeof ( int ) ) ) ; for ( int i = 0 ; i < array_size ; ++ i ) { local_ array [ i ] = rand ( ) % 100 ; } int local_ min = local_ array [ 0 ] ; int local_ max = local_ array [ 0 ] ; for ( int i = 1 ; i < array_size ; ++ i ) { if ( local_ array [ i ] < local_ min ) { local_ min = local_ array [ i ] ; } if ( local_ array [ i ] > local_ max ) { local_ max = local_ array [ i ] ; } } int global_ min ; int global_ max ; mp i_ all reduce ( & local_ min , & global_ min , 1 , mp i_ int , mp i_ min , mp i_ comm_ world ) ; mp i_ all reduce ( & local_ max , & global_ max , 1 , mp i_ int , mp i_ max , mp i_ comm_ world ) ; if ( rank == 0 ) { printf ( ___str , global_ min ) ; printf ( ___str , global_ max ) ; } free ( local_ array ) ; mp i_ finalize ( ) ; return 0 ; }
candidate: int main ( int argc , char * argv [ ] ) { int size ; int rank ; const int array_size = 100 ; mpi _init ( & argc , & argv ) ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; sr and ( rank ) ; int * local_ array = ( int * ) malloc ( array_size * ( sizeof ( int ) ) ) ; for ( int i = 0 ; i < array_size ; ++ i ) { local_ array [ i ] = rand ( ) % 100 ; } int local_ min = local_ array [ 0 ] ; int local_ max = local_ array [ 0 ] ; for ( int i = 1 ; i < array_size ; ++ i ) { if ( local_ array [ i ] < local_ min ) { local_ min = local_ array [ i ] ; } if ( local_ array [ i ] > local_ max ) { local_ max = local_ array [ i ] ; } } int global_ min ; int global_ max ; for ( int i = 0 ; i < ( sizeof ( local_ min ) ) ; i ++ ) { if ( local_ min [ i ] < global_ min ) { global_ min = local_ min [ i ] ; } } for ( int i = 0 ; i < ( sizeof ( local_ max ) ) ; i ++ ) { if ( local_ max [ i ] > global_ max ) { global_ max = local_ max [ i ] ; } } if ( rank == 0 ) { printf ( ___str , global_ max ) ; printf ( ___str , global_ max ) ; }

sample 7:
reference: int main ( int argc , char * argv [ ] ) { mpi _init ( & argc , & argv ) ; int size ; int rank ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; if ( size ! = 3 ) { printf ( ___str , 3 ) ; mp i_ abort ( mp i_ comm_ world , 1 ) ; } int matrix [ 3 ] [ 3 ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int vector [ 3 ] = { 1 , 2 , 3 } ; int local_ product [ 3 ] = { 0 } ; for ( int i = 0 ; i < 3 ; ++ i ) { for ( int j = 0 ; j < 3 ; ++ j ) { local_ product [ i ] += matrix [ rank ] [ j ] * vector [ j ] ; } } int global_ product [ 3 ] = { 0 } ; mp i_ all reduce ( local_ product , global_ product , 3 , mp i_ int , mpi _sum , mp i_ comm_ world ) ; if ( rank == 0 ) { printf ( ___str ) ; print matrix ( matrix , 3 ) ; printf ( ___str ) ; print vector ( vector ) ; printf ( ___str ) ; print vector ( global_ product ) ; } mp i_ finalize ( ) ; return 0 ; }
candidate: int main ( int argc , char * argv [ ] ) { int size ; int rank ; mpi _init ( & argc , & argv ) ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; if ( size ! = 3 ) { printf ( ___str , 3 ) ; mp i_ abort ( mp i_ comm_ world , 1 ) ; } int matrix [ 3 ] [ 3 ] = { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int vector [ 3 ] = { 1 , 2 , 3 } ; int local_ product [ 3 ] = { 0 } ; for ( int i = 0 ; i < 3 ; ++ i ) { for ( int j = 0 ; j < 3 ; ++ j ) { local_ product [ i ] += matrix [ rank ] [ j ] * vector [ j ] ; } } int global_ product [ 3 ] = { 0 } ; for ( int i = 0 ; i < ( sizeof ( local_ product ) ) ; i ++ ) { global_ product += local_ product [ i ] ; } mpi _g ather v ( & local_ product , 3 , mp i_ int , global_ product , 3 , mp i_ int , 0 , mp i_ comm_ world ) ; if ( rank == 0 ) { printf ( ___str ) ; print matrix ( matrix , 3 ) ; printf ( ___str ) ; print vector ( vector ) ; printf ( ___str ) ; print vector ( global_ product ) ; } mp i_ finalize ( )

sample 8:
reference: int main ( int argc , char * argv [ ] ) { mpi _init ( & argc , & argv ) ; int size ; int rank ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; int element s_per_ process = 1000000 / size ; int remaining_ elements = 1000000 % size ; int start_index = rank * element s_per_ process ; int end_index = start_index + element s_per_ process ; if ( rank == ( size - 1 ) ) { end_index += remaining_ elements ; } int * local_ array = ( int * ) malloc ( ( end_index - start_index ) * ( sizeof ( int ) ) ) ; for ( int i = 0 ; i < ( end_index - start_index ) ; ++ i ) { local_ array [ i ] = rand ( ) % 100 ; } long long local _sum = 0 ; for ( int i = 0 ; i < ( end_index - start_index ) ; ++ i ) { local _sum += local_ array [ i ] ; } long long global _sum = 0 ; mpi _reduce ( & local _sum , & global _sum , 1 , mp i_ long_ long _int , mpi _sum , 0 , mp i_ comm_ world ) ; if ( rank == 0 ) { printf ( ___str , global _sum ) ; } free ( local_ array ) ; mp i_ finalize ( ) ; return 0 ; }
candidate: int main ( int argc , char * argv [ ] ) { int size ; int rank ; int element s_per_ process = 1000000 / size ; int remaining_ elements = 1000000 % size ; int start_index = rank * element s_per_ process ; int end_index = start_index + element s_per_ process ; mpi _init ( & argc , & argv ) ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; if ( rank == ( size - 1 ) ) { end_index += remaining_ elements ; } int * local_ array = ( int * ) malloc ( ( end_index - start_index ) * ( sizeof ( int ) ) ) ; for ( int i = 0 ; i < ( end_index - start_index ) ; ++ i ) { local_ array [ i ] = rand ( ) % 100 ; } long long local _sum = 0 ; for ( int i = 0 ; i < ( end_index - start_index ) ; ++ i ) { local _sum += local_ array [ i ] ; } long long global _sum = 0 ; for ( int i = 0 ; i < ( sizeof ( local _sum ) ) ; i ++ ) { global _sum += local _sum [ i ] ; } mpi _reduce ( & local _sum , & global _sum , 1 , mp i_ int , mpi _sum , 0 , mp i_ comm_ world ) ; if ( rank == 0 ) { printf ( ___str , global _sum ) ; } free ( local_ array ) ; mp i_ finalize ( ) ; return 0 ; }

sample 9:
reference: int main ( int argc , char * argv [ ] ) { mpi _init ( & argc , & argv ) ; int size ; int rank ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; int * local_ array = ( int * ) malloc ( ( 100 / size ) * ( sizeof ( int ) ) ) ; for ( int i = 0 ; i < ( 100 / size ) ; ++ i ) { local_ array [ i ] = rand ( ) % 100 ; } merge sort ( local_ array , 0 , ( 100 / size ) - 1 ) ; int * sorted_ array = 0 ; if ( rank == 0 ) { sorted_ array = ( int * ) malloc ( 100 * ( sizeof ( int ) ) ) ; } mpi _g ather ( local_ array , 100 / size , mp i_ int , sorted_ array , 100 / size , mp i_ int , 0 , mp i_ comm_ world ) ; if ( rank == 0 ) { merge sort ( sorted_ array , 0 , 100 - 1 ) ; printf ( ___str ) ; for ( int i = 0 ; i < 100 ; ++ i ) { printf ( ___str , sorted_ array [ i ] ) ; } printf ( ___str ) ; free ( sorted_ array ) ; } free ( local_ array ) ; mp i_ finalize ( ) ; return 0 ; }
candidate: int main ( int argc , char * argv [ ] ) { int size ; int rank ; mpi _init ( & argc , & argv ) ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; int * local_ array = ( int * ) malloc ( ( 100 / size ) * ( sizeof ( int ) ) ) ; for ( int i = 0 ; i < ( 100 / size ) ; ++ i ) { local_ array [ i ] = rand ( ) % 100 ; } merge sort ( local_ array , 0 , ( 100 / size ) - 1 ) ; int * sorted_ array = 0 ; if ( rank == 0 ) { sorted_ array = ( int * ) malloc ( 100 * ( sizeof ( int ) ) ) ; } mpi _g ather ( local_ array , 100 , mp i_ int , sorted_ array , 100 , mp i_ int , 0 , mp i_ comm_ world ) ; if ( rank == 0 ) { merge sort ( sorted_ array , 0 , 100 - 1 ) ; printf ( ___str ) ; for ( int i = 0 ; i < 100 ; ++ i ) { printf ( ___str , sorted_ array [ i ] ) ; } printf ( ___str ) ; free ( sorted_ array ) ; } free ( local_ array ) ; mp i_ finalize ( ) ; return 0 ; }

sample 10:
reference: int main ( int argc , char * argv [ ] ) { mpi _init ( & argc , & argv ) ; int size ; int rank ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; int local_ points = 1000000 00 / size ; int local _inside _circle = 0 ; double x ; double y ; for ( int i = 0 ; i < local_ points ; i ++ ) { x = ( ( double ) rand ( ) ) / 32767 ; y = ( ( double ) rand ( ) ) / 32767 ; if ( ( ( x * x ) + ( y * y ) ) < = 1 . 0 ) { local _inside _circle ++ ; } } int total_ inside _circle = 0 ; mpi _reduce ( & local _inside _circle , & total_ inside _circle , 1 , mp i_ int , mpi _sum , 0 , mp i_ comm_ world ) ; if ( rank == 0 ) { double pi _estimate = ( 4 . 0 * total_ inside _circle ) / 1000000 00 ; printf ( ___str , pi _estimate ) ; } mp i_ finalize ( ) ; return 0 ; }
candidate: int main ( int argc , char * argv [ ] ) { int size ; int rank ; mpi _init ( & argc , & argv ) ; mp i_ comm_ size ( mp i_ comm_ world , & size ) ; mp i_ comm_ rank ( mp i_ comm_ world , & rank ) ; int local_ points = 1000000 00 / size ; int local aliz _circle = 0 ; double x ; double y ; for ( int i = 0 ; i < local_ points ; i ++ ) { x = ( ( double ) rand ( ) ) / 32767 ; y = ( ( double ) rand ( ) ) / 32767 ; if ( ( ( x * x ) + ( y * y ) ) < = 1 . 0 ) { local aliz _circle ++ ; } } int total_ inside _circle = 0 ; for ( int i = 0 ; i < ( sizeof ( local aliz _circle ) ) ; i ++ ) { total_ inside _circle += local aliz _circle [ i ] ; } mpi _reduce ( & total_ inside _circle , & total_ inside _circle , 1 , mp i_ double , mpi _sum , 0 , mp i_ comm_ world ) ; if ( rank == 0 ) { double pi _estimate = ( 4 . 0 * total_ inside _circle ) / 1000000 00 ; printf ( ___str , pi _estimate ) ; } mp i_ finalize ( ) ; return 0 ; }


test_loss: 1.5683727264404297
test_bleu: 0.8506818028309265
test_rouge-l: 0.8886764964735856
test_avg_precision: 0.8982307431237995
test_avg_recall: 0.9594571038756111
test_avg_f1: 0.9263533059612684
test_accuracy: 0.0
test_runtime: 277.0327
test_samples_per_second: 0.04
test_steps_per_second: 0.004


